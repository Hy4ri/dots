#!/usr/bin/env bash

PID_DIR=/tmp/hypr_sendkey
mkdir -p "$PID_DIR"

cleanup() {
  for f in "$PID_DIR"/*.pid; do
    [ -f "$f" ] || continue
    pid=$(cat "$f")
    kill "$pid" 2>/dev/null
    rm -f "$f"
  done
}

# DO NOT trap EXIT â€” this script is a launcher
trap cleanup INT TERM

resolve_class() {
  local class="$1"
  if [ "$class" = "active" ]; then
    hyprctl -j activewindow 2>/dev/null | jq -r '.class'
  else
    printf '%s\n' "$class"
  fi
}

stop_process() {
  local pid_file="$1"
  if [ -f "$pid_file" ]; then
    pid=$(cat "$pid_file")
    ps -p "$pid" >/dev/null 2>&1 && kill "$pid"
    rm -f "$pid_file"
    return 0
  fi
  return 1
}

repeat() {
  local pid_file="${PID_DIR}/repeat.pid"
  local class key

  class=$(resolve_class "$1")
  key="$2"

  if stop_process "$pid_file"; then
    hyprctl dispatch sendkeystate ,"$key",up,class:"$class"
    notify-send "Key $key repeating OFF"
  else
    (
      while true; do
        hyprctl --batch \
          "dispatch sendkeystate ,$key,down,class:$class; \
           dispatch sendkeystate ,$key,up,class:$class"
        sleep 0.005
      done
    ) &
    echo $! >"$pid_file"
    notify-send "Key $key is repeating on $class"
  fi
}

hold() {
  local pid_file="${PID_DIR}/hold.pid"
  local class key

  class=$(resolve_class "$1")
  key="$2"

  if stop_process "$pid_file"; then
    hyprctl dispatch sendkeystate ,"$key",up,class:"$class"
    notify-send "Holding key $key OFF"
  else
    (
      hyprctl dispatch sendkeystate ,"$key",down,class:"$class"
      while sleep 1; do :; done
    ) &
    echo $! >"$pid_file"
    notify-send "Holding key $key ON"
  fi
}

case "$1" in
  repeat) repeat "$2" "$3" ;;
  hold)   hold "$2" "$3" ;;
  *)
    echo "Usage: $0 {repeat|hold} <class> <key>"
    exit 1
    ;;
esac
