#!/usr/bin/env python3

import sys
import subprocess
import json
import urllib.request
import urllib.parse
import os
import hashlib
import time
import re
import argparse
from concurrent.futures import ThreadPoolExecutor

CACHE_DIR = os.path.expanduser("~/.cache/lyrics")

def ensure_dirs():
    os.makedirs(CACHE_DIR, exist_ok=True)

class PlayerManager:
    def __init__(self):
        self.player = None

    def get_active_player(self):
        try:
            # Get list of players
            result = subprocess.run(['playerctl', '-l'], capture_output=True, text=True)
            all_players = result.stdout.strip().split('\n')
            
            # Filter out ignored players
            players = [p for p in all_players if p and "vivaldi" not in p.lower() and "chromium" not in p.lower()]
            
            # Check for playing status first
            for p in players:
                status = self._get_player_status(p)
                if status == "Playing":
                    self.player = p
                    return p
            
            # Fallback to first available
            if players and players[0]:
                self.player = players[0]
                return players[0]
                
        except Exception:
            pass
        return None

    def _get_player_status(self, player):
        try:
            result = subprocess.run(['playerctl', '-p', player, 'status'], capture_output=True, text=True)
            return result.stdout.strip()
        except:
            return "Stopped"

    def get_metadata(self):
        if not self.player:
            return None
        
        try:
            # Get all metadata in one go
            cmd = ['playerctl', '-p', self.player, 'metadata', '--format', '{{title}}|||{{artist}}|||{{position}}|||{{mpris:length}}']
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode != 0:
                return None
                
            parts = result.stdout.strip().split('|||')
            if len(parts) < 3:
                return None
                
            title = parts[0]
            artist = parts[1]
            position = parts[2] # in microseconds
            length = parts[3] if len(parts) > 3 and parts[3] else "0"
            
            if not position: position = "0"
            
            OFFSET = 0.56
            
            return {
                "title": title,
                "artist": artist,
                "position": (int(float(position)) / 1000000) + OFFSET, # convert to seconds and add offset
                "length": int(length)
            }
        except Exception:
            return None

class LyricsFetcher:
    def get_hash(self, title, artist):
        query = f"{title} {artist}"
        return hashlib.md5(query.encode()).hexdigest()

    def get_cache_path(self, title, artist):
        return os.path.join(CACHE_DIR, self.get_hash(title, artist))
    
    def get_lock_path(self, title, artist):
        return os.path.join(CACHE_DIR, self.get_hash(title, artist) + ".lock")

    def clean_cache(self, current_hash):
        """Removes all cache files and locks that do not match the current song."""
        try:
            for filename in os.listdir(CACHE_DIR):
                path = os.path.join(CACHE_DIR, filename)
                # Keep current cache and current lock
                if filename == current_hash or filename == f"{current_hash}.lock":
                    continue
                try:
                    os.remove(path)
                except OSError:
                    pass
        except Exception:
            pass

    def fetch_background(self, title, artist):
        """Spawns a background process to fetch lyrics."""
        script_path = os.path.abspath(__file__)
        subprocess.Popen(
            [sys.executable, script_path, "--fetch", "--title", title, "--artist", artist],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True
        )

    def download_and_cache(self, title, artist):
        """Actual download logic run by background process."""
        query = f"{title} {artist}"
        cache_path = self.get_cache_path(title, artist)
        lock_path = self.get_lock_path(title, artist)
        
        # Create lock
        with open(lock_path, 'w') as f:
            f.write(str(time.time()))

        try:
            params = urllib.parse.urlencode({'q': query})
            url = f"https://lrclib.net/api/search?{params}"
            
            req = urllib.request.Request(url, headers={'User-Agent': 'WaybarLyrics/1.0'})
            with urllib.request.urlopen(req, timeout=10) as response:
                data = json.loads(response.read().decode())
                
            if isinstance(data, list) and len(data) > 0:
                # Find first synced lyrics
                for item in data:
                    if item.get('syncedLyrics'):
                        lyrics = item['syncedLyrics']
                        with open(cache_path, 'w') as f:
                            f.write(lyrics)
                        break
        except Exception as e:
            pass
        finally:
            if os.path.exists(lock_path):
                os.remove(lock_path)

class LrcParser:
    def parse(self, lrc_content):
        lines = []
        for line in lrc_content.split('\n'):
            match = re.match(r'\[(\d+):(\d+\.?\d*)\](.*)', line)
            if match:
                minutes = int(match.group(1))
                seconds = float(match.group(2))
                timestamp = minutes * 60 + seconds
                text = match.group(3).strip()
                lines.append({'time': timestamp, 'text': text})
        return lines

    def get_current_index(self, lines, position):
        idx = -1
        for i, line in enumerate(lines):
            if position >= line['time']:
                idx = i
            else:
                break
        return idx

    def get_context(self, lines, current_idx):
        if current_idx == -1:
            return []
        
        start = max(0, current_idx - 2)
        end = min(len(lines), current_idx + 3)
        
        context = []
        for i in range(start, end):
            text = lines[i]['text']
            if not text:
                line_content = "♫"
            else:
                line_content = f"♪ {text}"
                
            if i == current_idx:
                # Bold and bigger font for current line
                line_content = f"<span weight='bold' size='x-large'>{line_content}</span>"
            
            context.append(line_content)
            
        return context

def run_main():
    ensure_dirs()
    
    output = {
        "text": "",
        "tooltip": "",
        "class": "custom-lyrics"
    }

    try:
        player_mgr = PlayerManager()
        player = player_mgr.get_active_player()
        
        if not player:
            print(json.dumps(output))
            return

        meta = player_mgr.get_metadata()
        if not meta:
            print(json.dumps(output))
            return

        # 1. Pause Indicator
        status = player_mgr._get_player_status(player)
        pause_icon = "⏸ " if status == "Paused" else ""

        output['text'] = f"{pause_icon}{meta['title']} - {meta['artist']}"
        output['tooltip'] = f"{meta['title']} - {meta['artist']}"

        # Setup Fetcher
        fetcher = LyricsFetcher()
        current_hash = fetcher.get_hash(meta['title'], meta['artist'])
        cache_path = fetcher.get_cache_path(meta['title'], meta['artist'])
        lock_path = fetcher.get_lock_path(meta['title'], meta['artist'])

        # CLEANUP: Remove everything that isn't this song
        fetcher.clean_cache(current_hash)

        # Check Cache
        lrc_content = None
        if os.path.exists(cache_path):
            with open(cache_path, 'r') as f:
                lrc_content = f.read()
        elif not os.path.exists(lock_path):
            # No cache, no lock -> Start background fetch
            fetcher.fetch_background(meta['title'], meta['artist'])
        
        # 4. Progress Time
        time_str = ""
        if meta['length'] > 0:
            def format_time(seconds):
                m = int(seconds // 60)
                s = int(seconds % 60)
                return f"{m:02d}:{s:02d}"

            pos_str = format_time(meta['position'])
            len_str = format_time(meta['length'] / 1000000)
            time_str = f"[{pos_str}/{len_str}]"
            
        if lrc_content:
            parser = LrcParser()
            lines = parser.parse(lrc_content)
            current_idx = parser.get_current_index(lines, meta['position'])
            
            if current_idx != -1:
                current_text = lines[current_idx]['text']
                if not current_text:
                    output['text'] = f"{pause_icon}♫"
                else:
                    output['text'] = f"{pause_icon}{current_text}"
                
                context = parser.get_context(lines, current_idx)
                
                header = f"{meta['title']} - {meta['artist']}"
                if time_str:
                    header += f"\n{time_str}"
                
                output['tooltip'] = f"{header}\n\n" + "\n".join(context)
            else:
                 # Song started but no lyrics reached yet (intro)
                 output['tooltip'] += f"\n{time_str if time_str else ''}\n\n(Music)"
        else:
            # Loading state
            output['tooltip'] += f"\n{time_str if time_str else ''}\n\nLooking for lyrics..."

    except Exception as e:
        output['tooltip'] = f"Error: {str(e)}"
        
    print(json.dumps(output))

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--fetch", action="store_true", help="Run in fetch mode")
    parser.add_argument("--title", help="Song title")
    parser.add_argument("--artist", help="Song artist")
    args = parser.parse_args()

    ensure_dirs()

    if args.fetch:
        if args.title and args.artist:
            LyricsFetcher().download_and_cache(args.title, args.artist)
    else:
        run_main()
